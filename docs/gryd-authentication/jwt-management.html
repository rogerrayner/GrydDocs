<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JWT Management - GrydAuthentication Framework</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto px-6 py-8">
        <div class="bg-white rounded-lg shadow-md p-8">
            <div class="flex items-center mb-6">
                <a href="index.html" class="text-green-600 hover:text-green-800 mr-4">‚Üê Voltar</a>
                <h1 class="text-3xl font-bold text-gray-800">üé´ JWT Management</h1>
            </div>

            <!-- √çndice de Navega√ß√£o -->
            <div class="bg-gray-50 p-4 rounded-lg mb-8">
                <h3 class="text-lg font-semibold text-gray-800 mb-3">üìã √çndice</h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-2 text-sm">
                    <a href="#funcionalidades" class="text-blue-600 hover:text-blue-800">üîë Funcionalidades</a>
                    <a href="#configuracao-jwt" class="text-blue-600 hover:text-blue-800">‚öôÔ∏è Configura√ß√£o JWT</a>
                    <a href="#clean-architecture" class="text-blue-600 hover:text-blue-800 font-semibold bg-yellow-100 px-2 py-1 rounded">üèóÔ∏è Clean Architecture (NOVO)</a>
                    <a href="#servicos-jwt" class="text-blue-600 hover:text-blue-800">üîß Servi√ßos JWT</a>
                    <a href="#token-blacklist" class="text-blue-600 hover:text-blue-800">ÔøΩ Token Blacklist</a>
                    <a href="#seguranca-avancada" class="text-blue-600 hover:text-blue-800">ÔøΩÔ∏è Seguran√ßa Avan√ßada</a>
                    <a href="#middleware" class="text-blue-600 hover:text-blue-800">‚ö° Middleware</a>
                    <a href="#dtos" class="text-blue-600 hover:text-blue-800">üìã DTOs</a>
                    <a href="#extensoes" class="text-blue-600 hover:text-blue-800">üîß Extens√µes</a>
                </div>
            </div>

            <div class="prose max-w-none">
                <h2 id="funcionalidades">Gerenciamento de Tokens JWT</h2>
                <p>O GrydAuthentication Framework fornece um sistema completo de gerenciamento de tokens JWT com recursos avan√ßados de seguran√ßa, valida√ß√£o e renova√ß√£o autom√°tica.</p>

                <div class="bg-blue-50 p-4 rounded-lg border-l-4 border-blue-500 my-6">
                    <h3 class="text-blue-800 font-semibold">üîë Funcionalidades</h3>
                    <ul class="text-blue-700 mb-0">
                        <li>Gera√ß√£o e valida√ß√£o de tokens JWT</li>
                        <li>Refresh tokens seguros</li>
                        <li>Blacklist de tokens revogados</li>
                        <li>Rota√ß√£o autom√°tica de chaves</li>
                        <li>Claims customizadas</li>
                        <li>Valida√ß√£o de expira√ß√£o</li>
                    </ul>
                </div>

                <h2 id="configuracao-jwt">Configura√ß√£o JWT</h2>

                <h3>appsettings.json</h3>
                <pre><code class="language-json">{
  "Jwt": {
    "Issuer": "https://api.yourapp.com",
    "Audience": "https://api.yourapp.com",
    "SecretKey": "super-secure-secret-key-with-minimum-256-bits-for-security",
    "ExpirationMinutes": 60,
    "RefreshTokenExpirationDays": 30,
    "ValidateIssuer": true,
    "ValidateAudience": true,
    "ValidateLifetime": true,
    "ValidateIssuerSigningKey": true,
    "ClockSkew": "00:05:00",
    "Algorithm": "HS256",
    "EnableTokenBlacklist": true,
    "EnableKeyRotation": false,
    "KeyRotationIntervalDays": 90
  }
}</code></pre>

                <h3>Configura√ß√£o no Program.cs</h3>
                <pre><code class="language-csharp">using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;

var builder = WebApplication.CreateBuilder(args);

// Configurar JWT Authentication
builder.Services.AddAuthentication(options =&gt;
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =&gt;
{
    var jwtSettings = builder.Configuration.GetSection("Jwt");
    
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = jwtSettings.GetValue&lt;bool&gt;("ValidateIssuer"),
        ValidateAudience = jwtSettings.GetValue&lt;bool&gt;("ValidateAudience"),
        ValidateLifetime = jwtSettings.GetValue&lt;bool&gt;("ValidateLifetime"),
        ValidateIssuerSigningKey = jwtSettings.GetValue&lt;bool&gt;("ValidateIssuerSigningKey"),
        ValidIssuer = jwtSettings["Issuer"],
        ValidAudience = jwtSettings["Audience"],
        IssuerSigningKey = new SymmetricSecurityKey(
            Encoding.UTF8.GetBytes(jwtSettings["SecretKey"])),
        ClockSkew = TimeSpan.Parse(jwtSettings["ClockSkew"])
    };

    // Eventos personalizados
    options.Events = new JwtBearerEvents
    {
        OnTokenValidated = async context =&gt;
        {
            var tokenBlacklistService = context.HttpContext.RequestServices
                .GetRequiredService&lt;ITokenBlacklistService&gt;();
            
            var jti = context.Principal.FindFirst("jti")?.Value;
            if (!string.IsNullOrEmpty(jti) &amp;&amp; await tokenBlacklistService.IsBlacklistedAsync(jti))
            {
                context.Fail("Token has been revoked");
            }
        },
        OnAuthenticationFailed = context =&gt;
        {
            if (context.Exception is SecurityTokenExpiredException)
            {
                context.Response.Headers.Add("Token-Expired", "true");
            }
            return Task.CompletedTask;
        }
    };
});</code></pre>

                <h2 id="clean-architecture">üèóÔ∏è JWT Configuration - Clean Architecture Approach</h2>
                
                <div class="bg-yellow-50 p-4 rounded-lg border-l-4 border-yellow-500 my-6">
                    <h3 class="text-yellow-800 font-semibold">‚ö†Ô∏è Importante - Nova Arquitetura</h3>
                    <p class="text-yellow-700 mb-0">A partir da vers√£o atual, o GrydAuth Framework segue os princ√≠pios da Clean Architecture, permitindo que cada aplica√ß√£o host defina suas pr√≥prias configura√ß√µes JWT.</p>
                </div>

                <h3>üéØ Problema Resolvido</h3>
                <p>A implementa√ß√£o anterior violava os princ√≠pios SOLID e Clean Architecture ao ter o framework GrydAuth fortemente acoplado √†s suas pr√≥prias configura√ß√µes JWT. Isso impossibilitava que aplica√ß√µes host definissem suas pr√≥prias configura√ß√µes JWT.</p>

                <h3>‚úÖ Nova Arquitetura</h3>
                
                <h4>Separa√ß√£o de Responsabilidades:</h4>
                <ul>
                    <li><strong>GrydAuth Framework:</strong> Fornece servi√ßos e l√≥gica de neg√≥cio</li>
                    <li><strong>Aplica√ß√£o Host:</strong> Define configura√ß√µes de infraestrutura (JWT, bancos de dados, etc.)</li>
                </ul>

                <h4>Princ√≠pio da Invers√£o de Depend√™ncia:</h4>
                <ul>
                    <li>GrydAuth depende de abstra√ß√µes fornecidas pela aplica√ß√£o host</li>
                    <li>Aplica√ß√£o host controla todas as quest√µes de infraestrutura</li>
                </ul>

                <h3>üîß Implementa√ß√£o</h3>

                <h4>1. Mudan√ßas no GrydAuth Framework</h4>
                <pre><code class="language-csharp">// ANTIGO - Fortemente acoplado (ERRADO)
public static IServiceCollection AddInfrastructureServices(this IServiceCollection services, IConfiguration configuration)
{
    // ... registrar servi√ßos
    AddJwtAuthentication(services, configuration); // Usando config pr√≥pria do framework
    return services;
}

// NOVO - Fracamente acoplado (CORRETO) 
public static IServiceCollection AddInfrastructureServices(this IServiceCollection services, IConfiguration configuration)
{
    // ... registrar apenas servi√ßos
    // Configura√ß√£o JWT √© responsabilidade da APLICA√á√ÉO HOST
    return services;
}

// NOVO - M√©todo opcional para aplica√ß√µes host
public static IServiceCollection AddGrydAuthJwtAuthentication(this IServiceCollection services, IConfiguration configuration)
{
    // Configura√ß√£o JWT usando configura√ß√µes da APLICA√á√ÉO HOST
    var jwtSettings = configuration.GetSection("JwtSettings");
    // ... configurar JWT com settings do host
    return services;
}</code></pre>

                <h4>2. Configura√ß√£o da Aplica√ß√£o Host</h4>
                <pre><code class="language-csharp">private static void RegisterGrydAuthenticationInfrastructure(IServiceCollection services, IConfiguration configuration)
{
    // Registrar servi√ßos GrydAuth SEM configura√ß√£o autom√°tica de JWT
    services.AddInfrastructureServices(configuration);
    
    // Configura√ß√£o b√°sica (padr√£o: RequireHttpsMetadata = true)
    services.AddGrydAuthJwtAuthentication(configuration);
    
    // OU Configura√ß√£o customizada para desenvolvimento/produ√ß√£o
    services.AddGrydAuthJwtAuthentication(configuration, options =>
    {
        // Para desenvolvimento local
        options.RequireHttpsMetadata = false;
        
        // Eventos customizados
        options.Events = new JwtBearerEvents
        {
            OnAuthenticationFailed = context =>
            {
                // Log personalizado de falhas
                Console.WriteLine($"JWT Auth failed: {context.Exception.Message}");
                return Task.CompletedTask;
            }
        };
    });
}</code></pre>

                <h3>üìã Benef√≠cios</h3>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 my-6">
                    <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                        <h4 class="text-green-800 font-semibold">‚úÖ Conformidade com Princ√≠pios SOLID</h4>
                        <ul class="text-green-700 text-sm">
                            <li><strong>Responsabilidade √önica:</strong> Cada camada tem uma raz√£o para mudar</li>
                            <li><strong>Aberto/Fechado:</strong> Framework aberto para extens√£o, fechado para modifica√ß√£o</li>
                            <li><strong>Invers√£o de Depend√™ncia:</strong> Framework depende de abstra√ß√µes do host</li>
                        </ul>
                    </div>
                    
                    <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                        <h4 class="text-blue-800 font-semibold">‚úÖ Clean Architecture</h4>
                        <ul class="text-blue-700 text-sm">
                            <li><strong>Infraestrutura:</strong> Controlada pelas camadas externas (aplica√ß√£o host)</li>
                            <li><strong>Aplica√ß√£o:</strong> L√≥gica de neg√≥cio independente da infraestrutura</li>
                            <li><strong>Dom√≠nio:</strong> Regras de neg√≥cio puras</li>
                        </ul>
                    </div>
                </div>

                <div class="bg-purple-50 p-4 rounded-lg border border-purple-200 my-6">
                    <h4 class="text-purple-800 font-semibold">‚úÖ Benef√≠cios Pr√°ticos</h4>
                    <ul class="text-purple-700">
                        <li>Cada aplica√ß√£o pode definir suas pr√≥prias configura√ß√µes JWT</li>
                        <li>Framework permanece reutiliz√°vel entre diferentes projetos</li>
                        <li>Sem acoplamento forte a configura√ß√µes espec√≠ficas</li>
                        <li>Melhor testabilidade e manutenibilidade</li>
                    </ul>
                </div>

                <h3>üéØ Exemplo de Configura√ß√£o</h3>

                <h4>appsettings.json da Aplica√ß√£o Host:</h4>
                <pre><code class="language-json">{
  "JwtSettings": {
    "SecretKey": "sua-chave-secreta-da-aplicacao-host-256-bits",
    "Issuer": "NomeDaSuaAplicacao",
    "Audience": "NomeDaSuaAplicacao-API",
    "ExpirationInMinutes": 60,
    "RefreshTokenExpirationInDays": 7
  }
}</code></pre>

                <h4>Framework N√£o Precisa Mais:</h4>
                <ul>
                    <li>‚ùå Seu pr√≥prio appsettings.json para JWT</li>
                    <li>‚ùå Configura√ß√µes JWT hardcoded</li>
                    <li>‚ùå Valores espec√≠ficos de Issuer/Audience do framework</li>
                </ul>

                <div class="bg-gray-50 p-4 rounded-lg border-l-4 border-gray-500 my-6">
                    <h4 class="text-gray-800 font-semibold">üîë Princ√≠pio Fundamental</h4>
                    <blockquote class="text-gray-700 italic text-lg">
                        "Framework fornece capacidades, Aplica√ß√£o define pol√≠ticas"
                    </blockquote>
                    <p class="text-gray-600 mt-2 mb-0">O GrydAuth framework agora fornece capacidades JWT enquanto permite que cada aplica√ß√£o host defina suas pr√≥prias pol√≠ticas, segredos e configura√ß√µes JWT. Isso segue os princ√≠pios da Clean Architecture e torna o framework verdadeiramente reutiliz√°vel.</p>
                </div>

                <h2 id="servicos-jwt">Servi√ßos JWT</h2>

                <h3>IJwtService Interface</h3>
                <pre><code class="language-csharp">namespace GrydAuthenticationFramework.Application.Interfaces
{
    public interface IJwtService
    {
        Task&lt;string&gt; GenerateAccessTokenAsync(User user);
        Task&lt;string&gt; GenerateRefreshTokenAsync(Guid userId);
        Task&lt;ClaimsPrincipal&gt; ValidateTokenAsync(string token);
        Task&lt;bool&gt; ValidateRefreshTokenAsync(string refreshToken, Guid userId);
        Task RevokeTokenAsync(string jti);
        Task RevokeAllUserTokensAsync(Guid userId);
        Task&lt;TokenValidationResult&gt; ValidateTokenWithDetailsAsync(string token);
        Task&lt;string&gt; RefreshAccessTokenAsync(string refreshToken);
    }
}</code></pre>

                <h3>JwtService Implementation</h3>
                <pre><code class="language-csharp">using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;

namespace GrydAuthenticationFramework.Infrastructure.Services
{
    public class JwtService : IJwtService
    {
        private readonly JwtSettings _jwtSettings;
        private readonly ITokenBlacklistService _blacklistService;
        private readonly IUserRepository _userRepository;
        private readonly IRefreshTokenRepository _refreshTokenRepository;

        public JwtService(
            IOptions&lt;JwtSettings&gt; jwtSettings,
            ITokenBlacklistService blacklistService,
            IUserRepository userRepository,
            IRefreshTokenRepository refreshTokenRepository)
        {
            _jwtSettings = jwtSettings.Value;
            _blacklistService = blacklistService;
            _userRepository = userRepository;
            _refreshTokenRepository = refreshTokenRepository;
        }

        public async Task&lt;string&gt; GenerateAccessTokenAsync(User user)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.UTF8.GetBytes(_jwtSettings.SecretKey);
            
            var claims = await BuildClaimsAsync(user);
            
            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(claims),
                Expires = DateTime.UtcNow.AddMinutes(_jwtSettings.ExpirationMinutes),
                SigningCredentials = new SigningCredentials(
                    new SymmetricSecurityKey(key), 
                    SecurityAlgorithms.HmacSha256Signature),
                Issuer = _jwtSettings.Issuer,
                Audience = _jwtSettings.Audience
            };

            var token = tokenHandler.CreateToken(tokenDescriptor);
            return tokenHandler.WriteToken(token);
        }

        public async Task&lt;string&gt; GenerateRefreshTokenAsync(Guid userId)
        {
            var refreshToken = new RefreshToken(
                userId, 
                GenerateSecureToken(), 
                DateTime.UtcNow.AddDays(_jwtSettings.RefreshTokenExpirationDays));

            await _refreshTokenRepository.AddAsync(refreshToken);
            return refreshToken.Token;
        }

        public async Task&lt;ClaimsPrincipal&gt; ValidateTokenAsync(string token)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.UTF8.GetBytes(_jwtSettings.SecretKey);

            try
            {
                var validationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = _jwtSettings.ValidateIssuer,
                    ValidateAudience = _jwtSettings.ValidateAudience,
                    ValidateLifetime = _jwtSettings.ValidateLifetime,
                    ValidateIssuerSigningKey = _jwtSettings.ValidateIssuerSigningKey,
                    ValidIssuer = _jwtSettings.Issuer,
                    ValidAudience = _jwtSettings.Audience,
                    IssuerSigningKey = new SymmetricSecurityKey(key),
                    ClockSkew = TimeSpan.FromMinutes(5)
                };

                var principal = tokenHandler.ValidateToken(token, validationParameters, out var validatedToken);
                
                // Verificar blacklist
                var jti = principal.FindFirst("jti")?.Value;
                if (!string.IsNullOrEmpty(jti) &amp;&amp; await _blacklistService.IsBlacklistedAsync(jti))
                {
                    throw new SecurityTokenValidationException("Token has been revoked");
                }

                return principal;
            }
            catch (Exception ex)
            {
                throw new SecurityTokenValidationException($"Token validation failed: {ex.Message}");
            }
        }

        public async Task&lt;bool&gt; ValidateRefreshTokenAsync(string refreshToken, Guid userId)
        {
            var storedToken = await _refreshTokenRepository.GetByTokenAsync(refreshToken);
            
            return storedToken != null &amp;&amp; 
                   storedToken.UserId == userId &amp;&amp; 
                   storedToken.IsValid;
        }

        public async Task RevokeTokenAsync(string jti)
        {
            if (!string.IsNullOrEmpty(jti))
            {
                await _blacklistService.BlacklistTokenAsync(jti, DateTime.UtcNow.AddDays(1));
            }
        }

        public async Task RevokeAllUserTokensAsync(Guid userId)
        {
            // Blacklist todos os refresh tokens do usu√°rio
            var refreshTokens = await _refreshTokenRepository.GetByUserIdAsync(userId);
            foreach (var token in refreshTokens)
            {
                token.Revoke();
            }

            await _refreshTokenRepository.UpdateRangeAsync(refreshTokens);

            // Blacklist baseado em timestamp - tokens emitidos antes deste momento s√£o inv√°lidos
            await _blacklistService.BlacklistUserTokensAsync(userId, DateTime.UtcNow);
        }

        public async Task&lt;TokenValidationResult&gt; ValidateTokenWithDetailsAsync(string token)
        {
            try
            {
                var principal = await ValidateTokenAsync(token);
                var jwtToken = new JwtSecurityTokenHandler().ReadJwtToken(token);

                return new TokenValidationResult
                {
                    IsValid = true,
                    Principal = principal,
                    ExpiresAt = jwtToken.ValidTo,
                    IssuedAt = jwtToken.ValidFrom,
                    UserId = Guid.Parse(principal.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? ""),
                    Claims = principal.Claims.ToDictionary(c =&gt; c.Type, c =&gt; c.Value)
                };
            }
            catch (Exception ex)
            {
                return new TokenValidationResult
                {
                    IsValid = false,
                    ErrorMessage = ex.Message
                };
            }
        }

        public async Task&lt;string&gt; RefreshAccessTokenAsync(string refreshToken)
        {
            var storedToken = await _refreshTokenRepository.GetByTokenAsync(refreshToken);
            
            if (storedToken == null || !storedToken.IsValid)
            {
                throw new SecurityTokenValidationException("Invalid refresh token");
            }

            var user = await _userRepository.GetByIdAsync(storedToken.UserId);
            if (user == null || !user.IsActive)
            {
                throw new SecurityTokenValidationException("User not found or inactive");
            }

            // Revogar o refresh token usado
            storedToken.Revoke();
            await _refreshTokenRepository.UpdateAsync(storedToken);

            // Gerar novo access token
            var newAccessToken = await GenerateAccessTokenAsync(user);
            
            // Gerar novo refresh token
            var newRefreshToken = await GenerateRefreshTokenAsync(user.Id);

            return newAccessToken;
        }

        private async Task&lt;List&lt;Claim&gt;&gt; BuildClaimsAsync(User user)
        {
            var claims = new List&lt;Claim&gt;
            {
                new(ClaimTypes.NameIdentifier, user.Id.ToString()),
                new(ClaimTypes.Email, user.Email),
                new(ClaimTypes.Name, user.FullName),
                new("jti", Guid.NewGuid().ToString()),
                new("iat", DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(), ClaimValueTypes.Integer64),
                new("sub", user.Id.ToString())
            };

            // Adicionar roles
            var roles = user.RoleNames;
            foreach (var role in roles)
            {
                claims.Add(new Claim(ClaimTypes.Role, role));
            }

            // Adicionar permiss√µes
            var permissions = await GetUserPermissionsAsync(user.Id);
            foreach (var permission in permissions)
            {
                claims.Add(new Claim("permissions", permission));
            }

            // Claims customizadas
            if (!string.IsNullOrEmpty(user.FirstName))
                claims.Add(new Claim(ClaimTypes.GivenName, user.FirstName));
            
            if (!string.IsNullOrEmpty(user.LastName))
                claims.Add(new Claim(ClaimTypes.Surname, user.LastName));

            return claims;
        }

        private async Task&lt;List&lt;string&gt;&gt; GetUserPermissionsAsync(Guid userId)
        {
            var user = await _userRepository.GetByIdWithRolesAsync(userId);
            return user.UserRoles
                .SelectMany(ur =&gt; ur.Role.RolePermissions)
                .Select(rp =&gt; rp.Permission.Name)
                .Distinct()
                .ToList();
        }

        private string GenerateSecureToken()
        {
            using var rng = RandomNumberGenerator.Create();
            var bytes = new byte[64];
            rng.GetBytes(bytes);
            return Convert.ToBase64String(bytes);
        }
    }
}</code></pre>

                <h2 id="token-blacklist">Token Blacklist Service</h2>

                <h3>ITokenBlacklistService Interface</h3>
                <pre><code class="language-csharp">namespace GrydAuthenticationFramework.Application.Interfaces
{
    public interface ITokenBlacklistService
    {
        Task BlacklistTokenAsync(string jti, DateTime expiration);
        Task&lt;bool&gt; IsBlacklistedAsync(string jti);
        Task BlacklistUserTokensAsync(Guid userId, DateTime timestamp);
        Task&lt;bool&gt; IsUserTokenValidAsync(Guid userId, DateTime issuedAt);
        Task CleanupExpiredTokensAsync();
    }
}</code></pre>

                <h3>Redis-based Implementation</h3>
                <pre><code class="language-csharp">using StackExchange.Redis;

namespace GrydAuthenticationFramework.Infrastructure.Services
{
    public class RedisTokenBlacklistService : ITokenBlacklistService
    {
        private readonly IDatabase _database;
        private const string BlacklistedTokenPrefix = "blacklist:token:";
        private const string UserInvalidationPrefix = "blacklist:user:";

        public RedisTokenBlacklistService(IConnectionMultiplexer redis)
        {
            _database = redis.GetDatabase();
        }

        public async Task BlacklistTokenAsync(string jti, DateTime expiration)
        {
            var key = $"{BlacklistedTokenPrefix}{jti}";
            var ttl = expiration - DateTime.UtcNow;
            
            if (ttl &gt; TimeSpan.Zero)
            {
                await _database.StringSetAsync(key, "1", ttl);
            }
        }

        public async Task&lt;bool&gt; IsBlacklistedAsync(string jti)
        {
            var key = $"{BlacklistedTokenPrefix}{jti}";
            return await _database.KeyExistsAsync(key);
        }

        public async Task BlacklistUserTokensAsync(Guid userId, DateTime timestamp)
        {
            var key = $"{UserInvalidationPrefix}{userId}";
            var unixTimestamp = ((DateTimeOffset)timestamp).ToUnixTimeSeconds();
            
            // Armazenar por 30 dias (tempo m√°ximo de refresh token)
            await _database.StringSetAsync(key, unixTimestamp.ToString(), TimeSpan.FromDays(30));
        }

        public async Task&lt;bool&gt; IsUserTokenValidAsync(Guid userId, DateTime issuedAt)
        {
            var key = $"{UserInvalidationPrefix}{userId}";
            var invalidationTimestamp = await _database.StringGetAsync(key);
            
            if (!invalidationTimestamp.HasValue)
                return true;

            var invalidationTime = DateTimeOffset.FromUnixTimeSeconds(invalidationTimestamp);
            return issuedAt &gt; invalidationTime.DateTime;
        }

        public async Task CleanupExpiredTokensAsync()
        {
            // Redis limpa automaticamente com TTL, mas podemos implementar cleanup manual se necess√°rio
            await Task.CompletedTask;
        }
    }
}</code></pre>

                <h2>Middleware de JWT</h2>

                <h3>JwtMiddleware</h3>
                <pre><code class="language-csharp">namespace GrydAuthenticationFramework.Infrastructure.Middleware
{
    public class JwtMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly IJwtService _jwtService;
        private readonly ILogger&lt;JwtMiddleware&gt; _logger;

        public JwtMiddleware(RequestDelegate next, IJwtService jwtService, ILogger&lt;JwtMiddleware&gt; logger)
        {
            _next = next;
            _jwtService = jwtService;
            _logger = logger;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            var token = ExtractTokenFromHeader(context.Request);
            
            if (!string.IsNullOrEmpty(token))
            {
                try
                {
                    var validationResult = await _jwtService.ValidateTokenWithDetailsAsync(token);
                    
                    if (validationResult.IsValid)
                    {
                        context.User = validationResult.Principal;
                        
                        // Adicionar informa√ß√µes √∫teis ao contexto
                        context.Items["UserId"] = validationResult.UserId;
                        context.Items["TokenExpiresAt"] = validationResult.ExpiresAt;
                        context.Items["TokenIssuedAt"] = validationResult.IssuedAt;
                        
                        // Log successful validation
                        _logger.LogDebug("Token validated successfully for user {UserId}", validationResult.UserId);
                    }
                    else
                    {
                        _logger.LogWarning("Token validation failed: {Error}", validationResult.ErrorMessage);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error validating JWT token");
                }
            }

            await _next(context);
        }

        private string? ExtractTokenFromHeader(HttpRequest request)
        {
            var authHeader = request.Headers["Authorization"].FirstOrDefault();
            
            if (authHeader != null &amp;&amp; authHeader.StartsWith("Bearer "))
            {
                return authHeader.Substring("Bearer ".Length).Trim();
            }

            return null;
        }
    }
}</code></pre>

                <h2>DTOs de JWT</h2>

                <h3>TokenValidationResult</h3>
                <pre><code class="language-csharp">namespace GrydAuthenticationFramework.Application.DTOs.Auth
{
    public class TokenValidationResult
    {
        public bool IsValid { get; set; }
        public ClaimsPrincipal? Principal { get; set; }
        public DateTime? ExpiresAt { get; set; }
        public DateTime? IssuedAt { get; set; }
        public Guid UserId { get; set; }
        public Dictionary&lt;string, string&gt; Claims { get; set; } = new();
        public string? ErrorMessage { get; set; }
    }
}</code></pre>

                <h3>RefreshTokenRequest</h3>
                <pre><code class="language-csharp">namespace GrydAuthenticationFramework.Application.DTOs.Auth
{
    public class RefreshTokenRequest
    {
        [Required]
        public string RefreshToken { get; set; } = string.Empty;
        
        public string? AccessToken { get; set; }
    }

    public class RefreshTokenResponse
    {
        public string AccessToken { get; set; } = string.Empty;
        public string RefreshToken { get; set; } = string.Empty;
        public DateTime ExpiresAt { get; set; }
        public string TokenType { get; set; } = "Bearer";
    }
}</code></pre>

                <h2>Extens√µes √öteis</h2>

                <h3>ClaimsPrincipal Extensions</h3>
                <pre><code class="language-csharp">namespace GrydAuthenticationFramework.Extensions
{
    public static class ClaimsPrincipalExtensions
    {
        public static Guid GetUserId(this ClaimsPrincipal principal)
        {
            var userIdClaim = principal.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            return Guid.TryParse(userIdClaim, out var userId) ? userId : Guid.Empty;
        }

        public static string GetEmail(this ClaimsPrincipal principal)
        {
            return principal.FindFirst(ClaimTypes.Email)?.Value ?? string.Empty;
        }

        public static List&lt;string&gt; GetRoles(this ClaimsPrincipal principal)
        {
            return principal.FindAll(ClaimTypes.Role).Select(c =&gt; c.Value).ToList();
        }

        public static List&lt;string&gt; GetPermissions(this ClaimsPrincipal principal)
        {
            return principal.FindAll("permissions").Select(c =&gt; c.Value).ToList();
        }

        public static bool HasPermission(this ClaimsPrincipal principal, string permission)
        {
            return principal.FindAll("permissions").Any(c =&gt; c.Value == permission);
        }

        public static bool HasRole(this ClaimsPrincipal principal, string role)
        {
            return principal.IsInRole(role);
        }

        public static DateTime? GetTokenIssuedAt(this ClaimsPrincipal principal)
        {
            var iatClaim = principal.FindFirst("iat")?.Value;
            if (long.TryParse(iatClaim, out var iat))
            {
                return DateTimeOffset.FromUnixTimeSeconds(iat).DateTime;
            }
            return null;
        }

        public static string? GetJti(this ClaimsPrincipal principal)
        {
            return principal.FindFirst("jti")?.Value;
        }
    }
}</code></pre>

                <h2 id="seguranca-avancada">Configura√ß√£o de Seguran√ßa Avan√ßada</h2>

                <h3>Key Rotation (Opcional)</h3>
                <pre><code class="language-csharp">public class JwtKeyRotationService : IHostedService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger&lt;JwtKeyRotationService&gt; _logger;
    private Timer? _timer;

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        // Executar rota√ß√£o de chaves a cada 90 dias
        _timer = new Timer(RotateKeys, null, TimeSpan.Zero, TimeSpan.FromDays(90));
        await Task.CompletedTask;
    }

    private async void RotateKeys(object? state)
    {
        using var scope = _serviceProvider.CreateScope();
        var keyService = scope.ServiceProvider.GetRequiredService&lt;IJwtKeyService&gt;();
        
        try
        {
            await keyService.RotateKeysAsync();
            _logger.LogInformation("JWT keys rotated successfully");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to rotate JWT keys");
        }
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        _timer?.Dispose();
        return Task.CompletedTask;
    }
}</code></pre>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 my-8">
                    <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                        <h3 class="font-semibold text-green-800 mb-2">üë• Role-Based Access</h3>
                        <p class="text-sm text-green-600 mb-3">Sistema de controle de acesso baseado em roles</p>
                        <a href="role-based-access.html" class="text-green-600 text-sm font-medium hover:underline">
                            Ver Role-Based Access ‚Üí
                        </a>
                    </div>
                </div>

            <section id="middleware" class="mb-12">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 border-l-4 border-blue-500 pl-4">‚ö° Middleware JWT</h2>
                
                <div class="bg-gray-50 p-6 rounded-lg">
                    <h3 class="text-lg font-semibold mb-4">JwtMiddleware</h3>
                    <p class="text-gray-700 mb-4">Middleware para interceptar e validar tokens JWT automaticamente:</p>
                    
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto mb-4"><code>public class JwtMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var token = context.Request.Headers["Authorization"]
            .FirstOrDefault()?.Split(" ").Last();
            
        if (token != null)
        {
            await AttachUserToContext(context, token);
        }
        
        await next(context);
    }
}</code></pre>
                </div>
            </section>

            <section id="dtos" class="mb-12">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 border-l-4 border-blue-500 pl-4">üìã DTOs de Autentica√ß√£o</h2>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-gray-50 p-6 rounded-lg">
                        <h3 class="text-lg font-semibold mb-4">LoginRequestDto</h3>
                        <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code>public class LoginRequestDto
{
    public string Email { get; set; }
    public string Password { get; set; }
    public bool RememberMe { get; set; }
}</code></pre>
                    </div>
                    
                    <div class="bg-gray-50 p-6 rounded-lg">
                        <h3 class="text-lg font-semibold mb-4">AuthResponseDto</h3>
                        <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code>public class AuthResponseDto
{
    public string AccessToken { get; set; }
    public string RefreshToken { get; set; }
    public DateTime ExpiresAt { get; set; }
    public UserDto User { get; set; }
}</code></pre>
                    </div>
                </div>
            </section>

            <section id="extensoes" class="mb-12">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 border-l-4 border-blue-500 pl-4">üîß Extens√µes e Helpers</h2>
                
                <div class="bg-gray-50 p-6 rounded-lg">
                    <h3 class="text-lg font-semibold mb-4">JwtExtensions</h3>
                    <p class="text-gray-700 mb-4">Extens√µes √∫teis para trabalhar com JWT:</p>
                    
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto mb-4"><code>public static class JwtExtensions
{
    public static string GetUserId(this ClaimsPrincipal user)
    {
        return user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    }
    
    public static string GetUserEmail(this ClaimsPrincipal user)
    {
        return user.FindFirst(ClaimTypes.Email)?.Value;
    }
    
    public static bool IsTokenExpired(this JwtSecurityToken token)
    {
        return token.ValidTo < DateTime.UtcNow;
    }
}</code></pre>
                </div>
            </section>
            </div>
        </div>
    </div>

    <script>hljs.highlightAll();</script>
</body>
</html>
